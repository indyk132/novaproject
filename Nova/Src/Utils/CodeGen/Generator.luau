--[[
	Code Generation Module for Nova
	Generates Lua code snippets for remote calls.
]]

local CodeGen = {}

CodeGen.CleanTable = {}

local MethodMap = {
	Incoming = {
		RemoteEvent = "OnClientEvent",
		RemoteFunction = "OnClientInvoke",
		UnreliableRemoteEvent = "OnClientEvent",
		BindableEvent = "Event",
		BindableFunction = "OnInvoke",
	},

	Outgoing = {
		RemoteEvent = "FireServer",
		RemoteFunction = "InvokeServer",
		UnreliableRemoteEvent = "FireServer",
		BindableEvent = "Fire",
		BindableFunction = "Invoke",
	},
}

local GetNilCode = [[local function GetNil(Name, DebugId)
	for _, Object in getnilinstances() do
		if Object.Name == Name and Object:GetDebugId() == DebugId then
			return Object
		end
	end
end]]

-- Clean string characters
for i = 0, 31 do
	CodeGen.CleanTable[string.char(i)] = "\\" .. string.format("%03d", i)
end
for i = 127, 255 do
	CodeGen.CleanTable[string.char(i)] = "\\" .. string.format("%03d", i)
end

function CodeGen.FormatLuaString(str)
	local cleaned = string.gsub(str, ".", function(c)
		return CodeGen.CleanTable[c] or c
	end)
	cleaned = string.gsub(cleaned, '"', '\\"')
	return `"{cleaned}"`
end

function CodeGen.GetFullPath(instance, options)
	options = options or {}
	local VariableName = options.VariableName or "Remote"
	local DisableNilParentHandler = options.DisableNilParentHandler or false
	local UseMethod = wax.shared.SaveManager:GetState("PathMethod", "Index")

	if not instance then
		return `local {VariableName} = nil -- Instance not found`
	end

	local path = {}
	local current = instance
	local nilParent = false

	while current and current ~= game do
		table.insert(path, 1, current)
		if current.Parent == nil then
			nilParent = true
			break
		end
		current = current.Parent
	end

	if nilParent and not DisableNilParentHandler then
		local debugId = pcall(function() return instance:GetDebugId() end) and instance:GetDebugId() or "unknown"
		return `{GetNilCode}\n\nlocal {VariableName} = GetNil("{instance.Name}", "{debugId}")`
	end

	local code = ""
	local service = path[1]

	if service and service.Parent == game then
		code = `game:GetService("{service.ClassName}")`

		for i = 2, #path do
			local child = path[i]
			local name = child.Name

			if UseMethod == "FindFirstChild" then
				code ..= `:FindFirstChild("{name}")`
			elseif UseMethod == "WaitForChild" then
				code ..= `:WaitForChild("{name}")`
			else
				-- Index method
				if string.match(name, "^[%a_][%w_]*$") then
					code ..= `.{name}`
				else
					code ..= `["{name}"]`
				end
			end
		end
	else
		code = `workspace -- Could not resolve path for {instance.Name}`
	end

	return `local {VariableName} = {code}`
end

function CodeGen.GenerateCode(logEntry, callInfo, options)
	options = options or {}
	local ShowWatermark = wax.shared.SaveManager:GetState("ShowWatermark", true)
	local PreferBuffer = wax.shared.SaveManager:GetState("PreferBufferFromString", false)

	local instance = logEntry.Instance
	local eventType = logEntry.Type
	local className = instance.ClassName

	local method = MethodMap[eventType] and MethodMap[eventType][className]
	if not method then
		return "-- Unknown remote type"
	end

	local lines = {}

	-- Watermark
	if ShowWatermark then
		table.insert(lines, "-- Generated by Nova Remote Spy")
		table.insert(lines, "")
	end

	-- Path
	table.insert(lines, CodeGen.GetFullPath(instance, { VariableName = "Remote" }))
	table.insert(lines, "")

	-- Args
	if callInfo and callInfo.Args then
		local args = callInfo.Args
		if #args > 0 then
			local Success, Encoded = pcall(wax.shared.LuaEncode, args, {
				Prettify = true,
				FunctionsReturnRaw = true,
				UseInstancePaths = true,
			})

			if Success then
				table.insert(lines, `local Args = {Encoded}`)
				table.insert(lines, "")
				table.insert(lines, `Remote:{method}(unpack(Args))`)
			else
				table.insert(lines, `-- Failed to serialize args: {tostring(Encoded)}`)
				table.insert(lines, `Remote:{method}()`)
			end
		else
			table.insert(lines, `Remote:{method}()`)
		end
	else
		table.insert(lines, `Remote:{method}()`)
	end

	return table.concat(lines, "\n")
end

function CodeGen.GenerateInterceptCode(logEntry, options)
	options = options or {}
	local ShowWatermark = wax.shared.SaveManager:GetState("ShowWatermark", true)

	local instance = logEntry.Instance
	local eventType = logEntry.Type
	local className = instance.ClassName

	local lines = {}

	if ShowWatermark then
		table.insert(lines, "-- Generated by Nova Remote Spy (Intercept)")
		table.insert(lines, "")
	end

	table.insert(lines, CodeGen.GetFullPath(instance, { VariableName = "Remote" }))
	table.insert(lines, "")

	if eventType == "Outgoing" then
		if className == "RemoteEvent" or className == "UnreliableRemoteEvent" then
			table.insert(lines, [[local OldNamecall
OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
	if not checkcaller() and getnamecallmethod() == "FireServer" and self == Remote then
		-- Modify args here
		return OldNamecall(self, ...)
	end
	return OldNamecall(self, ...)
end))]])
		elseif className == "RemoteFunction" then
			table.insert(lines, [[local OldNamecall
OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
	if not checkcaller() and getnamecallmethod() == "InvokeServer" and self == Remote then
		-- Modify args or return value here
		return OldNamecall(self, ...)
	end
	return OldNamecall(self, ...)
end))]])
		end
	elseif eventType == "Incoming" then
		local connectionName = MethodMap.Incoming[className]
		if connectionName then
			table.insert(lines, `Remote.{connectionName}:Connect(function(...)`)
			table.insert(lines, `	print("Intercepted:", ...)`)
			table.insert(lines, `end)`)
		end
	end

	return table.concat(lines, "\n")
end

return CodeGen
